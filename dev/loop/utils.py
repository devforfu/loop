# -----------------------------------------
# THIS FILE WAS AUTOGENERATED! DO NOT EDIT!
# -----------------------------------------
# file to edit: 00c_utils.ipynb

from collections import OrderedDict
import math
import re

import numpy as np

from loop.annotations import Any, List, Dict, Tuple


__all__ = ['default', 'merge_dicts', 'to_snake_case', 'pairs', 'classname',
           'to_list', 'autoformat', 'is_scalar', 'broadcast', 'unwrap_if_single',
           'from_torch']


def default(x: Any, fallback: Any=None) -> Any:
    return x if x is not None else fallback


def merge_dicts(ds: List[Dict]) -> OrderedDict:
    """Merges a list of dictionaries into single dictionary.

    The order of dicts in the list affects the values of keys in the
    returned dict.
    """
    merged = OrderedDict()
    for d in ds:
        for k, v in d.items():
            merged[k] = v
    return merged


def to_snake_case(string: str) -> str:
    s = re.sub('(.)([A-Z][a-z]+)', r'\1_\2', string)
    return re.sub('([a-z0-9])([A-Z])', r'\1_\2', s).lower()


def pairs(seq: List) -> List[Tuple]:
    """Returns list of adjacent pairs: [1, 2, 3] -> [(1, 2), (2, 3)]."""
    assert len(seq) > 1
    yield from zip(seq[:-1], seq[1:])


def classname(x: Any) -> str:
    return x.__class__.__name__


def to_list(obj: Any) -> List:
    """Converts iterable into list or wraps a scalar value with list."""
    if isinstance(obj, str):
        return [obj]
    return list(obj) if hasattr(obj, '__len__') or hasattr(obj, '__next__') else [obj]


def autoformat(v):
    """Tryies to convert value into a string using the best possible representation."""

    return (f'{v:d}' if isinstance(v, (int, np.int16, np.int32, np.int64)) else
            f'{v:.4f}' if isinstance(v, (float, np.float16, np.float32, np.float64)) else
            f'{str(v)}')


def is_scalar(obj):
    return isinstance(obj, (int, float, str, complex))


def broadcast(obj, pad=1):
    """Convenience function to unwrap collections and broadcast scalars."""
    if is_scalar(obj):
        return [obj]*pad
    return obj


def unwrap_if_single(obj):
    """Converts obj collection into a scalar if it contains single element only."""
    return obj[0] if len(obj) == 1 else obj


def from_torch(tensor):
    """Converts torch tensor into Numpy array or scalar."""
    obj = tensor.detach().cpu()
    if not obj.shape:
        return obj.item()
    return obj.numpy()


def make_axis_if_needed(ax=None, **params):
    """Creates matplotlib axis but only if 'ax' is None."""
    if ax is None:
        _, ax = plt.subplots(1, 1, **params)
    return ax


def calculate_layout(num_axes, n_rows=None, n_cols=None):
    """Calculates number of rows/columns required to fit `num_axes` plots
    onto figure if specific number of columns/rows is specified.
    """
    if n_rows is not None and n_cols is not None:
        raise ValueError(
            'cannot derive number of rows/columns if both values provided')
    if n_rows is None and n_cols is None:
        n_cols = 2
    if n_rows is None:
        n_rows = max(1, math.ceil(num_axes / n_cols))
    else:
        n_cols = max(1, math.ceil(num_axes / n_rows))
    return n_rows, n_cols


def to_pickle(obj, path):
    with Path(path).open('wb') as f:
        pickle.dump(obj, f, protocol=pickle.HIGHEST_PROTOCOL)


def read_pickle(path):
    with Path(path).open('rb') as f:
        return pickle.load(f)


def combine(x, fn, *funcs):
    """Chains function calls on x argument like.

    If funcs contains list [f, g, h] then the final output is equal to h(g(f(x))).
    """
    funcs = [fn] + list(funcs)
    for func in funcs:
        x = func(x)
    return x
