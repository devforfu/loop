# -----------------------------------------
# THIS FILE WAS AUTOGENERATED! DO NOT EDIT!
# -----------------------------------------
# file to edit: 03c_predictions.ipynb

import matplotlib.pyplot as plt
import numpy as np
import torch
from torch.utils.data import Dataset, DataLoader, TensorDataset, Subset
from torch.utils.data.dataloader import default_collate

from loop.config import defaults
from loop.training import Loop
from loop.utils import from_torch


class Predictor:
    """Wraps model with """

    def __init__(self, model, device, batch_size: int=defaults.bs, loss_fn: 'callable'=None):
        model.to(device).eval()
        self.model = model
        self.device = device
        self.batch_size = batch_size
        self.loss_fn = loss_fn

    @classmethod
    def from_loop(cls, loop: Loop, on_device=None):
        return cls(loop.model, on_device or loop.device, loss_fn=loop.loss_fn)

    def predict_tensor(self, X, **params):
        y = torch.zeros(len(X)).long()
        return self.predict(TensorDataset(X, y), **params)

    def predict(self, ds: Dataset, **params):
        return self.predict_loader(DataLoader(ds, self.batch_size), **params)

    def predict_loader(self, dl: DataLoader, with_gt: bool=False):
        result, actual = [], []
        for xb, yb in dl:
            y_hat = self.model(xb.to(self.device))
            result += from_torch(y_hat).tolist()
            actual += from_torch(yb).tolist()
        result, actual = [torch.tensor(x) for x in (result, actual)]
        result = result.softmax(dim=1)
        return (result, actual) if with_gt else result

    def loss(self, ds, loss_fn=None):
        loss_fn = loss_fn or self.loss_fn
        if loss_fn is None:
            raise ValueError('cannot compute loss if self.loss_fn is None')
        results, gts = self.predict(ds, with_gt=True)
        return loss_fn(results, gts)

    def loss_tensor(self, X, y, loss_fn=None):
        return self.loss(TensorDataset(X, y), loss_fn)


class ImageClassifier(Predictor):

    def predict_classes(self, ds: Dataset):
        dl = DataLoader(ds, self.batch_size)
        preds = self.predict_loader(dl)
        classes = from_torch(preds.argmax(dim=-1))
        return classes

    def show_predictions(self, ds: Dataset, n: int=4, shuffle: bool=True, **fig_kwargs):
        total = n*n
        idx = (np.random.choice(len(ds), size=total, replace=True) if shuffle else
               np.arange(total))
        data, labels = default_collate([ds[i] for i in idx])
        classes = self.predict_classes(TensorDataset(data, labels))
        f, axes = plt.subplots(n, n, **fig_kwargs)
        for i in range(total):
            ax = axes.flat[i]
            ax.set_aspect('equal')
            img, label = [from_torch(t) for t in (ds.data[idx[i]], labels[i])]
            ax.imshow(img)
            ax.set_title(f'model={classes[i]}')
            ax.set_xlabel(f'gt={label}')
            ax.axis('off')
