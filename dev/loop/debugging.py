# -----------------------------------------
# THIS FILE WAS AUTOGENERATED! DO NOT EDIT!
# -----------------------------------------
# file to edit: 04a_debugging.ipynb

from pathlib import Path

import pandas as pd
import psutil

from loop.callbacks import Callback, Order


MB = 1024 ** 2
GB = 1024 * MB


class MemoryUsage(Callback):
    """A debugging callback used to track the amount of CPU memory used during training."""

    order = Order.Internal()

    def __init__(self, filename: str='memory.csv', units: int=GB):
        self.filename = filename
        self.units = units

    def training_started(self, **kwargs):
        self.iter = 0
        self._stream = self.open()
        self.write('index,mem_percent,mem_free,mem_available,mem_used')

    def training_ended(self, **kwargs):
        self.close()

    def batch_ended(self, **kwargs):
        self.iter += 1
        mem = psutil.virtual_memory()
        record = [self.iter, mem.percent, mem.available, mem.used]
        self.write(','.join([str(x) for x in record]))

    def plot(self, **fig_kwargs):
        mem = pd.read_csv(self.filename)
        index = mem.columns.str.startswith('mem')
        mem[mem.columns[index]] /= self.units
        f, ax = plt.subplots(2, 1, **fig_kwargs)
        ax1, ax2 = ax.flat
        unit_name = ('GB' if self.units == GB else
                     'MB' if self.units == MB else
                     '')
        self.plot_memory_percentage(ax1, mem)
        self.plot_memory_usage(ax2, mem, unit_name)

    @staticmethod
    def plot_memory_percentage(ax, mem):
        mem.plot(x='index', y='mem_percent', ax=ax)
        ax.set_title('Memory usage during training', fontsize=20)
        ax.set_xlabel('Batch Index', fontsize=16)
        ax.set_ylabel('Percentage', fontsize=16)

    @staticmethod
    def plot_memory_usage(ax, mem, y_label):
        mem.plot(x='index', y=['mem_available', 'mem_used'], ax=ax)
        ax.set_xlabel('Batch Index', fontsize=16)
        ax.set_ylabel(y_label, fontsize=16)

    def open(self):
        self.close()
        return Path(self.stream)

    def write(self, msg):
        breakpoint()
        self._stream.write(msg + '\n')
        self._stream.flush()

    def close(self):
        if self._stream is not None:
            self._stream.close()
            self._stream.flush()
            self._stream = None
