import json
import re
from operator import itemgetter
import glob
from pathlib import Path
import argparse


HEADER = '''
# -----------------------------------------
# THIS FILE WAS AUTOGENERATED! DO NOT EDIT!
# -----------------------------------------
# file to edit: {edit_file}

'''


def export(cell, min_size=7, types=('code',)):
    if cell['cell_type'] not in types:
        return False
    src, *_ = cell['source']
    if not src or len(src) < min_size:
        return False
    match = re.match(r'^\s*#\s*export\s*$', src, re.IGNORECASE)
    return match is not None


def find_notebooks(folder, ordered=True, pattern='*.ipynb'):
    """Goes through the folder and converts notebooks into Python scripts
    
    If ordered is True, then each notebook's name should start with a number.
    Otherwise, a notebook is ignored.
    """
    p = Path(folder)
    notebooks = list(p.glob(pattern))
    if ordered:
        items = []
        for filename in notebooks:
            m = re.match(r'^(\d+)([a-z]+)?_', filename.stem, re.IGNORECASE)
            if m is None:
                continue
            items.append((m.groups(), filename))
        items.sort(key=itemgetter(0))
        notebooks = [fn for _, fn in items]
    return notebooks


def export_notebooks(filenames, output, gap):
    count = 0
    empty_lines = '\n'*gap
    for fn in filenames:
        fn = Path(fn)
        content = json.load(fn.open('r'))
        module = HEADER.format(edit_file=fn.name)
        for cell in (c for c in content['cells'] if export(c)):
            module += f"{''.join(cell['source'][1:])}{empty_lines}"
        module = re.sub(r'[ \t]+$', '', module, flags=re.MULTILINE)
        pyfile = output/f"{''.join(fn.stem.partition('_')[2:])}.py"
        with pyfile.open('w') as file:
            file.write(module.strip() + '\n')
        print(f'Exported: {fn} -> {pyfile}')
        count += 1
    return count
        
        
if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('-nb', default=None)
    parser.add_argument('-o', dest='out', default='exported')
    parser.add_argument('-gap', type=int, default=3, help='number of empty lines between cells')
    args = vars(parser.parse_args())
    if args['nb'] is None:
        notebooks = find_notebooks(Path.cwd())
    else:
        notebooks = [args['nb']]
    output = Path(args['out'])
    if not output.exists():
        output.mkdir(parents=True)
    n = export_notebooks(notebooks, output, args['gap'])
    print(f'{n} notebook(s) exported into folder: {output}')
