# -----------------------------------------
# THIS FILE WAS AUTOGENERATED! DO NOT EDIT!
# -----------------------------------------
# file to edit: 03a_schedule.ipynb

from collections import defaultdict

import numpy as np
import pandas as pd

from loop.callbacks import Callback, Order
from loop.utils import calculate_layout


class CosineAnnealing:
    """A schedule that returns eta multiplier in range from 0.0 to 1.0."""

    def __init__(self, t_max, minmax=(0.0, 1.0), mult=2):
        self.t_max = t_max
        self.minmax = minmax
        self.mult = mult
        self.iter = 0

    def __call__(self, t):
        self.iter += 1
        (lo, hi), n = self.minmax, self.t_max
        x = self.iter % n
        eta = lo + (hi - lo)*(1 + np.cos(np.pi*x/n))/2
        if x == 0:
            self.iter = 0
            self.t_max *= self.mult
        return eta


def linear(epoch, t_max, minmax=(1e-7, 1)):
    """Simple linear schedule in minmax range."""
    lo, hi = minmax
    k = (hi - lo)/(t_max - 1)
    return k*epoch + lo


def cosine(epoch, t_max, ampl=1.0):
    """Shifted and scaled cosine function."""
    t = epoch % t_max
    return (1 + np.cos(np.pi*t/t_max))*ampl/2


def inv_cosine(epoch, t_max, ampl=0.6):
    """A cosine function reflected on X-axis."""
    return 1 - cosine(epoch, t_max, ampl)


def one_cycle(epoch, t_max, f1=inv_cosine, f2=cosine, pivot=0.3):
    """A combined schedule with two cosine half-waves."""
    pct = epoch / t_max
    if pct < pivot:
        return f1(epoch, pivot*t_max)
    return f2(epoch - pivot*t_max, (1-pivot)*t_max)


class Function:
    def __init__(self, func, **params):
        self.func = func
        self.params = params
    def __call__(self, t):
        return self.func(t, **self.params)


OneCycle = lambda **params: Function(one_cycle, **params)


class Scheduler(Callback):
    """Updates optimizer's learning rates using provided scheduling function."""

    order = Order.Schedule()

    def __init__(self, opt, schedule: 'callable', params: list=None, mode: str='batch'):
        assert mode in {'batch', 'epoch'}
        params = _make_sched_params(params)
        self.opt = opt
        self.schedule = schedule
        self.params = params
        self.n_steps = 0

    def training_started(self, **kwargs):
        self.history = defaultdict(list)

    def epoch_started(self, epoch, **kwargs):
        if self.mode == 'epoch':
            self.step(epoch)

    def batch_started(self, phase, **kwargs):
        if self.mode == 'batch':
            if phase.grad:
                self.step(phase.batch_index)

    def step(self, t):
        self.n_steps += 1
        mult = self.schedule(t)
        for i, group in enumerate(self.opt.param_groups):
            for item in self.params:
                name = item['name']
                if name not in group:
                    continue
                start = opt.defaults[name]
                inv = item.get('inverse', False)
                d = (1 - mult) if inv else mult
                absolute = item.get('absolute', False)
                new_value = d if absolute else start * d
                group[name] = new_value
                self.history[name].append(new_value)

    def plot(self, params=None, axes=None):
        params = params or ['lr']
        records = {'iteration': list(range(self.n_steps))}
        for conf in self.params:
            name = conf['name']
            if name in params:
                records[name] = self.history[name]
        df = pd.DataFrame(records)
        if axes is None:
            n = len(params)
            f, axes = plt.subplots(*calculate_layout(n))
        for i, param in enumerate(params):
            df.plot(x='iteration', y=param, ax=axes.flat[i])
        f.tight_layout()
        return axes


def _make_sched_params(params):
    if params is None:
        return [{'name': 'lr'}]
    converted = []
    for item in params:
        if isinstance(item, str):
            converted.append({'name': item})
        elif isinstance(item, dict):
            converted.append(item)
        else:
            raise TypeError(f'unexpected param type: {item}')
    return converted


class ScheduleCallback(Callback):
    """Wraps PyTorch scheduler with callback logic."""

    order = Order.Schedule()

    def __init__(self, schedule, history_metrics=('lr',)):
        self.schedule = schedule
        self.history_metrics = history_metrics
        self.history = []

    def after_backward(self, phase, batch_no):
        if not phase.grad:
            return
        iteration = phase.batch_index
        self.schedule.step(epoch=iteration)
        params = dict(iteration=iteration)
        for i, group in enumerate(self.group.opt.param_groups):
            params.update({
                f'{k}_{i}': v for k, v in group.items()
                if k in self.history_metrics})
        self.history.append(params)
